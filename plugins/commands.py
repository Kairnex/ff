import os
import logging
import random
import asyncio
import pytz
from Script import script
from datetime import datetime
from pyrogram import Client, filters, enums
from pyrogram.errors import ChatAdminRequired, FloodWait
from pyrogram.types import *
from database.ia_filterdb import Media, get_file_details, unpack_new_file_id, get_bad_files
from database.users_chats_db import db
from info import CHANNELS, ADMINS, AUTH_CHANNEL, LOG_CHANNEL, PICS, BATCH_FILE_CAPTION, CUSTOM_FILE_CAPTION, PROTECT_CONTENT, CHNL_LNK, GRP_LNK, REQST_CHANNEL, SUPPORT_CHAT_ID, SUPPORT_CHAT, MAX_B_TN
from utils import get_settings, get_size, is_req_subscribed, save_group_settings, temp
from database.connections_mdb import active_connection
import re
import sys
import json

logger = logging.getLogger(__name__)

TIMEZONE = "Asia/Kolkata"
BATCH_FILES = {}

@Client.on_message(filters.command("start") & filters.incoming)
async def start(client, message):
    if message.chat.type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        buttons = [[
            InlineKeyboardButton('Add To Group', url=f'http://t.me/{temp.U_NAME}?startgroup=true')
        ]]
        reply_markup = InlineKeyboardMarkup(buttons)
        await message.reply(
            script.GSTART_TXT.format(
                message.from_user.mention if message.from_user else message.chat.title,
                temp.U_NAME,
                temp.B_NAME
            ),
            reply_markup=reply_markup,
            disable_web_page_preview=True
        )
        await asyncio.sleep(2)
        if not await db.get_chat(message.chat.id):
            total = await client.get_chat_members_count(message.chat.id)
            await client.send_message(
                LOG_CHANNEL,
                script.LOG_TEXT_G.format(message.chat.title, message.chat.id, total, "Unknown")
            )
            await db.add_chat(message.chat.id, message.chat.title)
        return

    if not await db.is_user_exist(message.from_user.id):
        await db.add_user(message.from_user.id, message.from_user.first_name)
        await client.send_message(
            LOG_CHANNEL,
            script.LOG_TEXT_P.format(message.from_user.id, message.from_user.mention)
        )

    buttons = [[
        InlineKeyboardButton('Add To Group', url=f'http://telegram.me/{temp.U_NAME}?startgroup=true')
    ], [
        InlineKeyboardButton('Updates', callback_data='channels')
    ], [
        InlineKeyboardButton('Commands', callback_data='help')
    ], [
        InlineKeyboardButton('‚Ä¢ ·¥Ä ô·¥è·¥ú·¥õ ‚Ä¢', callback_data='about')
    ]]
    reply_markup = InlineKeyboardMarkup(buttons)

    current_time = datetime.now(pytz.timezone(TIMEZONE))
    curr_time = current_time.hour

    if curr_time < 12:
        gtxt = "…¢·¥è·¥è·¥Ö ·¥ç·¥è Ä…¥…™…¥…¢ üëã"
    elif curr_time < 17:
        gtxt = "…¢·¥è·¥è·¥Ö ·¥Ä“ì·¥õ·¥á Ä…¥·¥è·¥è…¥ üëã"
    elif curr_time < 21:
        gtxt = "…¢·¥è·¥è·¥Ö ·¥á·¥†·¥á…¥…™…¥…¢ üëã"
    else:
        gtxt = "…¢·¥è·¥è·¥Ö …¥…™…¢ ú·¥õ üëã"

    m = await message.reply_text("<i>·¥°·¥á ü·¥Ñ·¥è·¥ç·¥á ·¥õ·¥è <b>·¥õ ú·¥á ·¥ç·¥è·¥†…™·¥á ·¥ò Ä·¥è·¥†…™·¥Ö·¥á Ä  ô·¥è·¥õ</b>.\n ú·¥è·¥ò·¥á  è·¥è·¥ú' Ä·¥á ·¥Ö·¥è…™…¥…¢ ·¥°·¥á ü ü...</i>")
    await asyncio.sleep(0.4)
    await m.edit_text("üëÄ")
    await asyncio.sleep(0.5)
    await m.edit_text("‚ö°")
    await asyncio.sleep(0.5)
    await m.edit_text("<b><i>Íú±·¥õ·¥Ä Ä·¥õ…™…¥…¢...</i></b>")
    await asyncio.sleep(0.4)
    await m.delete()

    m = await message.reply_sticker("CAACAgQAAxkBAAEKeqNlIpmeUoOEsEWOWEiPxPi3hH5q-QACbg8AAuHqsVDaMQeY6CcRojAE")
    await asyncio.sleep(1)
    await m.delete()

    await message.reply_photo(
        photo=random.choice(PICS),
        caption=script.START_TXT.format(message.from_user.mention, gtxt, temp.U_NAME, temp.B_NAME),
        reply_markup=reply_markup,
        parse_mode=enums.ParseMode.HTML
    )
        return  
    data = message.command[1]
    try:
        pre, file_id = data.split('_', 1)
    except:
        file_id = data
        pre = ""
    if data.split("-", 1)[0] == "BATCH":
        sts = await message.reply("<b>Please wait...</b>")
        file_id = data.split("-", 1)[1]
        msgs = BATCH_FILES.get(file_id)
        if not msgs:
            file = await client.download_media(file_id)
            try: 
                with open(file) as file_data:
                    msgs=json.loads(file_data.read())
            except:
                await sts.edit("FAILED")
                return await client.send_message(LOG_CHANNEL, "UNABLE TO OPEN FILE.")
            os.remove(file)
            BATCH_FILES[file_id] = msgs
        for msg in msgs:
            title = msg.get("title")
            size=get_size(int(msg.get("size", 0)))
            f_caption=msg.get("caption", "")
            if BATCH_FILE_CAPTION:
                try:
                    f_caption=BATCH_FILE_CAPTION.format(file_name= '' if title is None else title, file_size='' if size is None else size, file_caption='' if f_caption is None else f_caption)
                except Exception as e:
                    logger.exception(e)
                    f_caption=f_caption
            if f_caption is None:
                f_caption = f"{title}"
            try:
                await client.send_cached_media(
                    chat_id=message.from_user.id,
                    file_id=msg.get("file_id"),
                    caption=f_caption,
                    protect_content=msg.get('protect', False),
                    reply_markup=InlineKeyboardMarkup(
                        [
                            [
                                InlineKeyboardButton(' Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á ', callback_data=f'generate_stream_link:{file_id}'),
                            ],
                            [
                                InlineKeyboardButton('Update Channel', url=f'https://t.me/earaxsupport') #Don't change anything without contacting me @thechiku
                            ]
                        ]
                    )
                )
            except FloodWait as e:
                await asyncio.sleep(e.x)
                logger.warning(f"Floodwait of {e.x} sec.")
                await client.send_cached_media(
                    chat_id=message.from_user.id,
                    file_id=msg.get("file_id"),
                    caption=f_caption,
                    protect_content=msg.get('protect', False),
                    reply_markup=InlineKeyboardMarkup(
                        [
                            [
                                InlineKeyboardButton(' Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á ', callback_data=f'generate_stream_link:{file_id}'),
                            ],
                            [
                                InlineKeyboardButton('Update Channel', url=f'https://t.me/earaxsupport') #Don't change anything without contacting me @thechiku
                            ]
                        ]
                    )
                )
            except Exception as e:
                logger.warning(e, exc_info=True)
                continue
            await asyncio.sleep(1) 
        await sts.delete()
        return
    
    elif data.split("-", 1)[0] == "DSTORE":
        sts = await message.reply("<b>Please wait...</b>")
        b_string = data.split("-", 1)[1]
        decoded = (base64.urlsafe_b64decode(b_string + "=" * (-len(b_string) % 4))).decode("ascii")
        try:
            f_msg_id, l_msg_id, f_chat_id, protect = decoded.split("_", 3)
        except:
            f_msg_id, l_msg_id, f_chat_id = decoded.split("_", 2)
            protect = "/pbatch" if PROTECT_CONTENT else "batch"
        diff = int(l_msg_id) - int(f_msg_id)
        async for msg in client.iter_messages(int(f_chat_id), int(l_msg_id), int(f_msg_id)):
            if msg.media:
                media = getattr(msg, msg.media.value)
                if BATCH_FILE_CAPTION:
                    try:
                        f_caption=BATCH_FILE_CAPTION.format(file_name=getattr(media, 'file_name', ''), file_size=getattr(media, 'file_size', ''), file_caption=getattr(msg, 'caption', ''))
                    except Exception as e:
                        logger.exception(e)
                        f_caption = getattr(msg, 'caption', '')
                else:
                    media = getattr(msg, msg.media.value)
                    file_name = getattr(media, 'file_name', '')
                    f_caption = getattr(msg, 'caption', file_name)
                try:
                    await msg.copy(message.chat.id, caption=f_caption, protect_content=True if protect == "/pbatch" else False)
                except FloodWait as e:
                    await asyncio.sleep(e.x)
                    await msg.copy(message.chat.id, caption=f_caption, protect_content=True if protect == "/pbatch" else False)
                except Exception as e:
                    logger.exception(e)
                    continue
            elif msg.empty:
                continue
            else:
                try:
                    await msg.copy(message.chat.id, protect_content=True if protect == "/pbatch" else False)
                except FloodWait as e:
                    await asyncio.sleep(e.x)
                    await msg.copy(message.chat.id, protect_content=True if protect == "/pbatch" else False)
                except Exception as e:
                    logger.exception(e)
                    continue
            await asyncio.sleep(1) 
        return await sts.delete()


    msg = await client.send_cached_media(
        chat_id=message.from_user.id,
        file_id=file_id,
        caption=f_caption,
        protect_content=True if pre == 'filep' else False,
        reply_markup=InlineKeyboardMarkup(
            [
             [
              InlineKeyboardButton('üöÄ Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üßø', callback_data=f'generate_stream_link:{file_id}'),
             ],
             [
              InlineKeyboardButton('Update Channel', url=f'https://t.me/earaxsupport') #Don't change anything without contacting me @thechiku
             ]
            ]
        )
    )
    btn = [[
        InlineKeyboardButton("‚ùó …¢·¥á·¥õ Íú∞…™ ü·¥á ·¥Ä…¢·¥Ä…™…¥ ‚ùó", callback_data=f'delfile#{file_id}')
    ]]
    k = await client.send_message(chat_id = message.from_user.id, text=f"<b>‚ùóÔ∏è <u>…™·¥ç·¥ò·¥è Ä·¥õ·¥Ä…¥·¥õ</u> ‚ùóÔ∏è</b>\n\n<b>·¥õ ú…™Íú± ·¥†…™·¥Ö·¥á·¥è / Íú∞…™ ü·¥á ·¥°…™ ü ü  ô·¥á ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö …™…¥</b> <b><u>10 ·¥ç…™…¥·¥ú·¥õ·¥áÍú±</u> </b><b>(·¥Ö·¥ú·¥á ·¥õ·¥è ·¥Ñ·¥è·¥ò è Ä…™…¢ ú·¥õ …™Íú±Íú±·¥ú·¥áÍú±).</b>\n\n<b><i>üìå ·¥ò ü·¥á·¥ÄÍú±·¥á Íú∞·¥è Ä·¥°·¥Ä Ä·¥Ö ·¥õ ú…™Íú± ·¥†…™·¥Ö·¥á·¥è / Íú∞…™ ü·¥á ·¥õ·¥è Íú±·¥è·¥ç·¥á·¥° ú·¥á Ä·¥á ·¥á üÍú±·¥á ·¥Ä…¥·¥Ö Íú±·¥õ·¥Ä Ä·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢ ·¥õ ú·¥á Ä·¥á.</i></b>")
    await asyncio.sleep(600)
    await msg.delete()
    await k.edit_text("<b> è·¥è·¥ú Ä ·¥†…™·¥Ö·¥á·¥è / Íú∞…™ ü·¥á …™Íú± Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö !!\n\n·¥Ñ ü…™·¥Ñ·¥ã  ô·¥á ü·¥è·¥°  ô·¥ú·¥õ·¥õ·¥è…¥ ·¥õ·¥è …¢·¥á·¥õ  è·¥è·¥ú Ä ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö ·¥†…™·¥Ö·¥á·¥è / Íú∞…™ ü·¥á üëá</b>",reply_markup=InlineKeyboardMarkup(btn))
    return  

@Client.on_message(filters.command('channel') & filters.user(ADMINS))
async def channel_info(bot, message):
           
    """Send basic information of channel"""
    if isinstance(CHANNELS, (int, str)):
        channels = [CHANNELS]
    elif isinstance(CHANNELS, list):
        channels = CHANNELS
    else:
        raise ValueError("·¥ú…¥·¥áx·¥ò·¥á·¥Ñ·¥õ·¥á·¥Ö ·¥õ è·¥ò·¥á ·¥èÍú∞ ·¥Ñ ú·¥Ä…¥…¥·¥á üÍú±.")

    text = 'üìë **…™…¥·¥Ö·¥áx·¥á·¥Ö ·¥Ñ ú·¥Ä…¥…¥·¥á üÍú± / …¢ Ä·¥è·¥ú·¥òÍú±  ü…™Íú±·¥õ :**\n'
    for channel in channels:
        chat = await bot.get_chat(channel)
        if chat.username:
            text += '\n@' + chat.username
        else:
            text += '\n' + chat.title or chat.first_name

    text += f'\n\n**·¥õ·¥è·¥õ·¥Ä ü :** {len(CHANNELS)}'

    if len(text) < 4096:
        await message.reply(text)
    else:
        file = 'Indexed channels.txt'
        with open(file, 'w') as f:
            f.write(text)
        await message.reply_document(file)
        os.remove(file)


@Client.on_message(filters.command('logs') & filters.user(ADMINS))
async def log_file(bot, message):
    """Send log file"""
    try:
        await message.reply_document('TELEGRAM BOT.LOG')
    except Exception as e:
        await message.reply(str(e))

@Client.on_message(filters.command('delete') & filters.user(ADMINS))
async def delete(bot, message):
    """Delete file from database"""
    reply = message.reply_to_message
    if reply and reply.media:
        msg = await message.reply("·¥ò Ä·¥è·¥Ñ·¥áÍú±Íú±…™…¥…¢...‚è≥", quote=True)
    else:
        await message.reply(' Ä·¥á·¥ò ü è ·¥õ·¥è Íú∞…™ ü·¥á ·¥°…™·¥õ ú /delete ·¥° ú…™·¥Ñ ú  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ö·¥á ü·¥á·¥õ·¥á Íú∞ Ä·¥è·¥ç ·¥Ö ô.', quote=True)
        return

    for file_type in ("document", "video", "audio"):
        media = getattr(reply, file_type, None)
        if media is not None:
            break
    else:
        await msg.edit('·¥õ ú…™Íú± …™Íú± …¥·¥è·¥õ Íú±·¥ú·¥ò·¥ò·¥è Ä·¥õ·¥á·¥Ö Íú∞…™ ü·¥á Íú∞·¥è Ä·¥ç·¥Ä·¥õ.')
        return
    
    file_id, file_ref = unpack_new_file_id(media.file_id)

    result = await Media.collection.delete_one({
        '_id': file_id,
    })
    if result.deleted_count:
        await msg.edit('Íú∞…™ ü·¥á …™Íú± Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö Íú∞ Ä·¥è·¥ç ·¥Ö ô ‚úÖ')
    else:
        file_name = re.sub(r"(_|\-|\.|\+)", " ", str(media.file_name))
        result = await Media.collection.delete_many({
            'file_name': file_name,
            'file_size': media.file_size,
            'mime_type': media.mime_type
            })
        if result.deleted_count:
            await msg.edit('Íú∞…™ ü·¥á …™Íú± Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö Íú∞ Ä·¥è·¥ç ·¥Ö ô ‚úÖ')
        else:
            # files indexed before https://github.com/EvamariaTG/EvaMaria/commit/f3d2a1bcb155faf44178e5d7a685a1b533e714bf#diff-86b613edf1748372103e94cacff3b578b36b698ef9c16817bb98fe9ef22fb669R39 
            # have original file name.
            result = await Media.collection.delete_many({
                'file_name': media.file_name,
                'file_size': media.file_size,
                'mime_type': media.mime_type
            })
            if result.deleted_count:
                await msg.edit('Íú∞…™ ü·¥á …™Íú± Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö Íú∞ Ä·¥è·¥ç ·¥Ö ô ‚úÖ')
            else:
                await msg.edit('Íú∞…™ ü·¥á …™Íú± …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö …™…¥ ·¥Ö ô ‚ùå')


@Client.on_message(filters.command('deleteall') & filters.user(ADMINS))
async def delete_all_index(bot, message):
    await message.reply_text(
        '·¥õ ú…™Íú± ·¥°…™ ü ü ·¥Ö·¥á ü·¥á·¥õ·¥á ·¥Ä ü ü  è·¥è·¥ú Ä …™…¥·¥Ö·¥áx·¥á·¥Ö Íú∞…™ ü·¥áÍú± !\n·¥Ö·¥è  è·¥è·¥ú Íú±·¥õ…™ ü ü ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ñ·¥è…¥·¥õ…™…¥·¥ú·¥á ?',
        reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        text="‚ö†Ô∏è  è·¥áÍú± ‚ö†Ô∏è", callback_data="autofilter_delete"
                    )
                ],
                [
                    InlineKeyboardButton(
                        text="‚ùå …¥·¥è ‚ùå", callback_data="close_data"
                    )
                ],
            ]
        ),
        quote=True,
    )


@Client.on_callback_query(filters.regex(r'autofilter_delete'))
async def delete_all_index_confirm(bot, message):
    await Media.collection.drop()
    await message.answer('·¥ç·¥Ä…™…¥·¥õ·¥Ä…™…¥·¥á·¥Ö  ô è :  ú·¥ò')
    await message.message.edit('Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö ·¥Ä ü ü …™…¥·¥Ö·¥áx·¥á·¥Ö Íú∞…™ ü·¥áÍú± ‚úÖ')


@Client.on_message(filters.command('settings'))
async def settings(client, message):
    userid = message.from_user.id if message.from_user else None
    if not userid:
        return await message.reply(f" è·¥è·¥ú' Ä·¥á ·¥Ä…¥·¥è…¥ è·¥ç·¥è·¥úÍú± ·¥Ä·¥Ö·¥ç…™…¥.\n·¥úÍú±·¥á /connect {message.chat.id} …™…¥ ·¥ò·¥ç.")
    chat_type = message.chat.type

    if chat_type == enums.ChatType.PRIVATE:
        grpid = await active_connection(str(userid))
        if grpid is not None:
            grp_id = grpid
            try:
                chat = await client.get_chat(grpid)
                title = chat.title
            except:
                await message.reply_text("·¥ç·¥Ä·¥ã·¥á Íú±·¥ú Ä·¥á …™'·¥ç ·¥ò Ä·¥áÍú±·¥á…¥·¥õ …™…¥  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò !!", quote=True)
                return
        else:
            await message.reply_text("…™'·¥ç …¥·¥è·¥õ ·¥Ñ·¥è…¥…¥·¥á·¥Ñ·¥õ·¥á·¥Ö ·¥õ·¥è ·¥Ä…¥ è …¢ Ä·¥è·¥ú·¥ò !", quote=True)
            return

    elif chat_type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        grp_id = message.chat.id
        title = message.chat.title

    else:
        return

    st = await client.get_chat_member(grp_id, userid)
    if (
            st.status != enums.ChatMemberStatus.ADMINISTRATOR
            and st.status != enums.ChatMemberStatus.OWNER
            and str(userid) not in ADMINS
    ):
        return
    
    settings = await get_settings(grp_id)

    try:
        if settings['max_btn']:
            settings = await get_settings(grp_id)
    except KeyError:
        await save_group_settings(grp_id, 'max_btn', False)
        settings = await get_settings(grp_id)
    if 'is_shortlink' not in settings.keys():
        await save_group_settings(grp_id, 'is_shortlink', False)
    else:
        pass

    if settings is not None:
        buttons = [        
                [
                InlineKeyboardButton(
                    ' Ä·¥áÍú±·¥ú ü·¥õ ·¥ò·¥Ä…¢·¥á',
                    callback_data=f'setgs#button#{settings["button"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    ' ô·¥ú·¥õ·¥õ·¥è…¥' if settings["button"] else '·¥õ·¥áx·¥õ',
                    callback_data=f'setgs#button#{settings["button"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    'Íú∞…™ ü·¥á Íú±·¥á…¥·¥Ö ·¥ç·¥è·¥Ö·¥á',
                    callback_data=f'setgs#botpm#{settings["botpm"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    'Íú±·¥õ·¥Ä Ä·¥õ' if settings["botpm"] else '·¥Ä·¥ú·¥õ·¥è',
                    callback_data=f'setgs#botpm#{settings["botpm"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    'Íú∞…™ ü·¥á Íú±·¥á·¥Ñ·¥ú Ä·¥á',
                    callback_data=f'setgs#file_secure#{settings["file_secure"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    '·¥á…¥·¥Ä ô ü·¥á' if settings["file_secure"] else '·¥Ö…™Íú±·¥Ä ô ü·¥á',
                    callback_data=f'setgs#file_secure#{settings["file_secure"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    '…™·¥ç·¥Ö ô ·¥ò·¥èÍú±·¥õ·¥á Ä',
                    callback_data=f'setgs#imdb#{settings["imdb"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    '·¥á…¥·¥Ä ô ü·¥á' if settings["imdb"] else '·¥Ö…™Íú±·¥Ä ô ü·¥á',
                    callback_data=f'setgs#imdb#{settings["imdb"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    'Íú±·¥ò·¥á ü ü ·¥Ñ ú·¥á·¥Ñ·¥ã',
                    callback_data=f'setgs#spell_check#{settings["spell_check"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    '·¥á…¥·¥Ä ô ü·¥á' if settings["spell_check"] else '·¥Ö…™Íú±·¥Ä ô ü·¥á',
                    callback_data=f'setgs#spell_check#{settings["spell_check"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    '·¥°·¥á ü·¥Ñ·¥è·¥ç·¥á ·¥çÍú±…¢',
                    callback_data=f'setgs#welcome#{settings["welcome"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    '·¥á…¥·¥Ä ô ü·¥á' if settings["welcome"] else '·¥Ö…™Íú±·¥Ä ô ü·¥á',
                    callback_data=f'setgs#welcome#{settings["welcome"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    '·¥Ä·¥ú·¥õ·¥è ·¥Ö·¥á ü·¥á·¥õ·¥á',
                    callback_data=f'setgs#auto_delete#{settings["auto_delete"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    '·¥á…¥·¥Ä ô ü·¥á' if settings["auto_delete"] else '·¥Ö…™Íú±·¥Ä ô ü·¥á',
                    callback_data=f'setgs#auto_delete#{settings["auto_delete"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    '·¥Ä·¥ú·¥õ·¥è Íú∞…™ ü·¥õ·¥á Ä',
                    callback_data=f'setgs#auto_ffilter#{settings["auto_ffilter"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    '·¥á…¥·¥Ä ô ü·¥á' if settings["auto_ffilter"] else '·¥Ö…™Íú±·¥Ä ô ü·¥á',
                    callback_data=f'setgs#auto_ffilter#{settings["auto_ffilter"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    '·¥ç·¥Äx  ô·¥ú·¥õ·¥õ·¥è…¥Íú±',
                    callback_data=f'setgs#max_btn#{settings["max_btn"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    '10' if settings["max_btn"] else f'{MAX_B_TN}',
                    callback_data=f'setgs#max_btn#{settings["max_btn"]}#{grp_id}',
                ),
            ],
            ],
            [
                InlineKeyboardButton('‚áã ·¥Ñ ü·¥èÍú±·¥á Íú±·¥á·¥õ·¥õ…™…¥…¢Íú± ·¥ç·¥á…¥·¥ú ‚áã', 
                                     callback_data='close_data'
                                     )
            ]
        ]
        

        btn = [[
                InlineKeyboardButton("üë§ ·¥è·¥ò·¥á…¥ …™…¥ ·¥ò Ä…™·¥†·¥Ä·¥õ·¥á ·¥Ñ ú·¥Ä·¥õ üë§", callback_data=f"opnsetpm#{grp_id}")
              ],[
                InlineKeyboardButton("üë• ·¥è·¥ò·¥á…¥  ú·¥á Ä·¥á üë•", callback_data=f"opnsetgrp#{grp_id}")
              ]]

        reply_markup = InlineKeyboardMarkup(buttons)
        if chat_type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
            await message.reply_text(
                text="<b>·¥° ú·¥á Ä·¥á ·¥Ö·¥è  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥è·¥ò·¥á…¥ Íú±·¥á·¥õ·¥õ…™…¥…¢Íú± ·¥ç·¥á…¥·¥ú ? ‚öôÔ∏è</b>",
                reply_markup=InlineKeyboardMarkup(btn),
                disable_web_page_preview=True,
                parse_mode=enums.ParseMode.HTML,
                reply_to_message_id=message.id
            )
        else:
            await message.reply_text(
                text=f"<b>·¥Ñ ú·¥Ä…¥…¢·¥á  è·¥è·¥ú Ä Íú±·¥á·¥õ·¥õ…™…¥…¢Íú± Íú∞·¥è Ä {title} ·¥ÄÍú±  è·¥è·¥ú ·¥°…™Íú± ú ‚öô</b>",
                reply_markup=reply_markup,
                disable_web_page_preview=True,
                parse_mode=enums.ParseMode.HTML,
                reply_to_message_id=message.id
            )



@Client.on_message(filters.command('set_template'))
async def save_template(client, message):
    sts = await message.reply("·¥Ñ ú·¥á·¥Ñ·¥ã…™…¥…¢ ·¥õ·¥á·¥ç·¥ò ü·¥Ä·¥õ·¥á...")
    userid = message.from_user.id if message.from_user else None
    if not userid:
        return await message.reply(f" è·¥è·¥ú' Ä·¥á ·¥Ä…¥·¥è…¥ è·¥ç·¥è·¥úÍú± ·¥Ä·¥Ö·¥ç…™…¥.\n·¥úÍú±·¥á /connect {message.chat.id} …™…¥ ·¥ò·¥ç.")
    chat_type = message.chat.type

    if chat_type == enums.ChatType.PRIVATE:
        grpid = await active_connection(str(userid))
        if grpid is not None:
            grp_id = grpid
            try:
                chat = await client.get_chat(grpid)
                title = chat.title
            except:
                await message.reply_text("·¥ç·¥Ä·¥ã·¥á Íú±·¥ú Ä·¥á …™'·¥ç ·¥ò Ä·¥áÍú±·¥á…¥·¥õ …™…¥  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò !!", quote=True)
                return
        else:
            await message.reply_text("…™'·¥ç …¥·¥è·¥õ ·¥Ñ·¥è…¥…¥·¥á·¥Ñ·¥õ·¥á·¥Ö ·¥õ·¥è ·¥Ä…¥ è …¢ Ä·¥è·¥ú·¥ò !", quote=True)
            return

    elif chat_type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        grp_id = message.chat.id
        title = message.chat.title

    else:
        return

    st = await client.get_chat_member(grp_id, userid)
    if (
            st.status != enums.ChatMemberStatus.ADMINISTRATOR
            and st.status != enums.ChatMemberStatus.OWNER
            and str(userid) not in ADMINS
    ):
        return

    if len(message.command) < 2:
        return await sts.edit("…¥·¥è …™…¥·¥ò·¥ú·¥õ !")
    template = message.text.split(" ", 1)[1]
    await save_group_settings(grp_id, 'template', template)
    await sts.edit(f"‚úÖ Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥Ñ ú·¥Ä…¥…¢·¥á·¥Ö ·¥õ·¥á·¥ç·¥ò ü·¥Ä·¥õ·¥á Íú∞·¥è Ä <code>{title}</code> ·¥õ·¥è\n\n{template}")


@Client.on_message((filters.command(["request", "Request"]) | filters.regex("#request") | filters.regex("#Request")) & filters.group)
async def requests(bot, message):
    if REQST_CHANNEL is None or SUPPORT_CHAT_ID is None: return # Must add REQST_CHANNEL and SUPPORT_CHAT_ID to use this feature
    if message.reply_to_message and SUPPORT_CHAT_ID == message.chat.id:
        chat_id = message.chat.id
        reporter = str(message.from_user.id)
        mention = message.from_user.mention
        success = True
        content = message.reply_to_message.text
        try:
            if REQST_CHANNEL is not None:
                btn = [[
                        InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{message.reply_to_message.link}"),
                        InlineKeyboardButton('Íú± ú·¥è·¥° ·¥è·¥ò·¥õ…™·¥è…¥Íú±', callback_data=f'show_option#{reporter}')
                      ]]
                reported_post = await bot.send_message(chat_id=REQST_CHANNEL, text=f"<b>üìù  Ä·¥á«´·¥ú·¥áÍú±·¥õ : <u>{content}</u>\n\nüìö  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö  ô è : {mention}\nüìñ  Ä·¥á·¥ò·¥è Ä·¥õ·¥á Ä …™·¥Ö : {reporter}\n\n¬©Ô∏è ·¥õ ú·¥á ·¥ç·¥è·¥†…™·¥á ·¥ò Ä·¥è·¥†…™·¥Ö·¥á Ä‚Ñ¢</b>", reply_markup=InlineKeyboardMarkup(btn))
                success = True
            elif len(content) >= 3:
                for admin in ADMINS:
                    btn = [[
                        InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{message.reply_to_message.link}"),
                        InlineKeyboardButton('Íú± ú·¥è·¥° ·¥è·¥ò·¥õ…™·¥è…¥Íú±', callback_data=f'show_option#{reporter}')
                      ]]
                    reported_post = await bot.send_message(chat_id=admin, text=f"<b>üìù  Ä·¥á«´·¥ú·¥áÍú±·¥õ : <u>{content}</u>\n\nüìö  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö  ô è : {mention}\nüìñ  Ä·¥á·¥ò·¥è Ä·¥õ·¥á Ä …™·¥Ö : {reporter}\n\n¬©Ô∏è ·¥õ ú·¥á ·¥ç·¥è·¥†…™·¥á ·¥ò Ä·¥è·¥†…™·¥Ö·¥á Ä‚Ñ¢</b>", reply_markup=InlineKeyboardMarkup(btn))
                    success = True
            else:
                if len(content) < 3:
                    await message.reply_text("<b> è·¥è·¥ú ·¥ç·¥úÍú±·¥õ ·¥õ è·¥ò·¥á ·¥Ä ô·¥è·¥ú·¥õ  è·¥è·¥ú Ä  Ä·¥á«´·¥ú·¥áÍú±·¥õ [·¥ç…™…¥…™·¥ç·¥ú·¥ç 3 ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú±].  Ä·¥á«´·¥ú·¥áÍú±·¥õÍú± ·¥Ñ·¥Ä…¥'·¥õ  ô·¥á ·¥á·¥ç·¥ò·¥õ è.</b>")
            if len(content) < 3:
                success = False
        except Exception as e:
            await message.reply_text(f"Error: {e}")
            pass
        
    elif SUPPORT_CHAT_ID == message.chat.id:
        chat_id = message.chat.id
        reporter = str(message.from_user.id)
        mention = message.from_user.mention
        success = True
        content = message.text
        keywords = ["#request", "/request", "#Request", "/Request"]
        for keyword in keywords:
            if keyword in content:
                content = content.replace(keyword, "")
        try:
            if REQST_CHANNEL is not None and len(content) >= 3:
                btn = [[
                        InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{message.link}"),
                        InlineKeyboardButton('Íú± ú·¥è·¥° ·¥è·¥ò·¥õ…™·¥è…¥Íú±', callback_data=f'show_option#{reporter}')
                      ]]
                reported_post = await bot.send_message(chat_id=REQST_CHANNEL, text=f"<b>üìù  Ä·¥á«´·¥ú·¥áÍú±·¥õ : <u>{content}</u>\n\nüìö  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö  ô è : {mention}\nüìñ  Ä·¥á·¥ò·¥è Ä·¥õ·¥á Ä …™·¥Ö : {reporter}\n\n¬©Ô∏è ·¥õ ú·¥á ·¥ç·¥è·¥†…™·¥á ·¥ò Ä·¥è·¥†…™·¥Ö·¥á Ä‚Ñ¢</b>", reply_markup=InlineKeyboardMarkup(btn))
                success = True
            elif len(content) >= 3:
                for admin in ADMINS:
                    btn = [[
                        InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{message.link}"),
                        InlineKeyboardButton('Íú± ú·¥è·¥° ·¥è·¥ò·¥õ…™·¥è…¥Íú±', callback_data=f'show_option#{reporter}')
                      ]]
                    reported_post = await bot.send_message(chat_id=admin, text=f"<b>üìù  Ä·¥á«´·¥ú·¥áÍú±·¥õ : <u>{content}</u>\n\nüìö  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö  ô è : {mention}\nüìñ  Ä·¥á·¥ò·¥è Ä·¥õ·¥á Ä …™·¥Ö : {reporter}\n\n¬©Ô∏è ·¥õ ú·¥á ·¥ç·¥è·¥†…™·¥á ·¥ò Ä·¥è·¥†…™·¥Ö·¥á Ä‚Ñ¢</b>", reply_markup=InlineKeyboardMarkup(btn))
                    success = True
            else:
                if len(content) < 3:
                    await message.reply_text("<b> è·¥è·¥ú ·¥ç·¥úÍú±·¥õ ·¥õ è·¥ò·¥á ·¥Ä ô·¥è·¥ú·¥õ  è·¥è·¥ú Ä  Ä·¥á«´·¥ú·¥áÍú±·¥õ [·¥ç…™…¥…™·¥ç·¥ú·¥ç 3 ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú±].  Ä·¥á«´·¥ú·¥áÍú±·¥õÍú± ·¥Ñ·¥Ä…¥'·¥õ  ô·¥á ·¥á·¥ç·¥ò·¥õ è.</b>")
            if len(content) < 3:
                success = False
        except Exception as e:
            await message.reply_text(f"Error: {e}")
            pass
     
    elif SUPPORT_CHAT_ID == message.chat.id:
        chat_id = message.chat.id
        reporter = str(message.from_user.id)
        mention = message.from_user.mention
        success = True
        content = message.text
        keywords = ["#request", "/request", "#Request", "/Request"]
        for keyword in keywords:
            if keyword in content:
                content = content.replace(keyword, "")
        try:
            if REQST_CHANNEL is not None and len(content) >= 3:
                btn = [[
                        InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{message.link}"),
                        InlineKeyboardButton('Íú± ú·¥è·¥° ·¥è·¥ò·¥õ…™·¥è…¥Íú±', callback_data=f'show_option#{reporter}')
                      ]]
                reported_post = await bot.send_message(chat_id=REQST_CHANNEL, text=f"<b>üìù  Ä·¥á«´·¥ú·¥áÍú±·¥õ : <u>{content}</u>\n\nüìö  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö  ô è : {mention}\nüìñ  Ä·¥á·¥ò·¥è Ä·¥õ·¥á Ä …™·¥Ö : {reporter}\n\n¬©Ô∏è ·¥õ ú·¥á ·¥ç·¥è·¥†…™·¥á ·¥ò Ä·¥è·¥†…™·¥Ö·¥á Ä‚Ñ¢</b>", reply_markup=InlineKeyboardMarkup(btn))
                success = True
            elif len(content) >= 3:
                for admin in ADMINS:
                    btn = [[
                        InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{message.link}"),
                        InlineKeyboardButton('Íú± ú·¥è·¥° ·¥è·¥ò·¥õ…™·¥è…¥Íú±', callback_data=f'show_option#{reporter}')
                      ]]
                    reported_post = await bot.send_message(chat_id=admin, text=f"<b>üìù  Ä·¥á«´·¥ú·¥áÍú±·¥õ : <u>{content}</u>\n\nüìö  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö  ô è : {mention}\nüìñ  Ä·¥á·¥ò·¥è Ä·¥õ·¥á Ä …™·¥Ö : {reporter}\n\n¬©Ô∏è ·¥õ ú·¥á ·¥ç·¥è·¥†…™·¥á ·¥ò Ä·¥è·¥†…™·¥Ö·¥á Ä‚Ñ¢</b>", reply_markup=InlineKeyboardMarkup(btn))
                    success = True
            else:
                if len(content) < 3:
                    await message.reply_text("<b> è·¥è·¥ú ·¥ç·¥úÍú±·¥õ ·¥õ è·¥ò·¥á ·¥Ä ô·¥è·¥ú·¥õ  è·¥è·¥ú Ä  Ä·¥á«´·¥ú·¥áÍú±·¥õ [·¥ç…™…¥…™·¥ç·¥ú·¥ç 3 ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú±].  Ä·¥á«´·¥ú·¥áÍú±·¥õÍú± ·¥Ñ·¥Ä…¥'·¥õ  ô·¥á ·¥á·¥ç·¥ò·¥õ è.</b>")
            if len(content) < 3:
                success = False
        except Exception as e:
            await message.reply_text(f"Error: {e}")
            pass

    else:
        success = False
    
    if success:
        '''if isinstance(REQST_CHANNEL, (int, str)):
            channels = [REQST_CHANNEL]
        elif isinstance(REQST_CHANNEL, list):
            channels = REQST_CHANNEL
        for channel in channels:
            chat = await bot.get_chat(channel)
        #chat = int(chat)'''
        link = await bot.create_chat_invite_link(int(REQST_CHANNEL))
        btn = [[
                InlineKeyboardButton('·¥ä·¥è…™…¥ ·¥Ñ ú·¥Ä…¥…¥·¥á ü', url=link.invite_link),
                InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{reported_post.link}")
              ]]
        await message.reply_text("<b> è·¥è·¥ú Ä  Ä·¥á«´·¥ú·¥áÍú±·¥õ  ú·¥ÄÍú±  ô·¥á·¥á…¥ ·¥Ä·¥Ö·¥Ö·¥á·¥Ö! ·¥ò ü·¥á·¥ÄÍú±·¥á ·¥°·¥Ä…™·¥õ Íú∞·¥è Ä Íú±·¥è·¥ç·¥á ·¥õ…™·¥ç·¥á.\n\n·¥ä·¥è…™…¥ ·¥Ñ ú·¥Ä…¥…¥·¥á ü Íú∞…™ ÄÍú±·¥õ & ·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ.</b>", reply_markup=InlineKeyboardMarkup(btn))
    
@Client.on_message(filters.command("send") & filters.user(ADMINS))
async def send_msg(bot, message):
    if message.reply_to_message:
        target_id = message.text.split(" ", 1)[1]
        out = "Users Saved In DB Are:\n\n"
        success = False
        try:
            user = await bot.get_users(target_id)
            users = await db.get_all_users()
            async for usr in users:
                out += f"{usr['id']}"
                out += '\n'
            if str(user.id) in str(out):
                await message.reply_to_message.copy(int(user.id))
                success = True
            else:
                success = False
            if success:
                await message.reply_text(f"<b> è·¥è·¥ú Ä ·¥ç·¥áÍú±Íú±·¥Ä…¢·¥á  ú·¥ÄÍú±  ô·¥á·¥á…¥ Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è Íú±·¥á…¥·¥õ ·¥õ·¥è {user.mention}.</b>")
            else:
                await message.reply_text("<b>·¥õ ú…™Íú± ·¥úÍú±·¥á Ä ·¥Ö…™·¥Ö…¥'·¥õ Íú±·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ·¥õ ú…™Íú±  ô·¥è·¥õ  è·¥á·¥õ !</b>")
        except Exception as e:
            await message.reply_text(f"<b>Error: {e}</b>")
    else:
        await message.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥ÄÍú± ·¥Ä  Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä…¥ è ·¥ç·¥áÍú±Íú±·¥Ä…¢·¥á ·¥úÍú±…™…¥…¢ ·¥õ ú·¥á ·¥õ·¥Ä Ä…¢·¥á·¥õ ·¥Ñ ú·¥Ä·¥õ …™·¥Ö. Íú∞·¥è Ä ·¥á…¢:  /send ·¥úÍú±·¥á Ä…™·¥Ö</b>")

@Client.on_message(filters.command("deletefiles") & filters.user(ADMINS))

async def deletemultiplefiles(bot, message):

    chat_type = message.chat.type

    if chat_type != enums.ChatType.PRIVATE:

        return await message.reply_text(f"<b> ú·¥á è {message.from_user.mention},\n·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥°·¥è…¥'·¥õ ·¥°·¥è Ä·¥ã …™…¥ …¢ Ä·¥è·¥ú·¥òÍú± !\n…™·¥õ ·¥è…¥ ü è ·¥°·¥è Ä·¥ãÍú± …™…¥ ·¥ç è ·¥ò·¥ç.</b>")

    else:

        pass

    try:

        keyword = message.text.split(" ", 1)[1]

    except:

        return await message.reply_text(f"<b> ú·¥á è {message.from_user.mention},\n…¢…™·¥†·¥á ·¥ç·¥á ·¥Ä ·¥ã·¥á è·¥°·¥è Ä·¥Ö ·¥Ä ü·¥è…¥…¢ ·¥°…™·¥õ ú ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥õ·¥è ·¥Ö·¥á ü·¥á·¥õ·¥á Íú∞…™ ü·¥áÍú±.</b>")

    btn = [[

       InlineKeyboardButton("‚ö†Ô∏è  è·¥áÍú±, ·¥Ñ·¥è…¥·¥õ…™…¥·¥ú·¥á ‚ö†Ô∏è", callback_data=f"killfilesdq#{keyword}")

       ],[

       InlineKeyboardButton("‚ùå …¥·¥è, ·¥Ä ô·¥è Ä·¥õ ·¥è·¥ò·¥á Ä·¥Ä·¥õ…™·¥è…¥ ‚ùå", callback_data="close_data")

    ]]

    await message.reply_text(

        text="<b>·¥Ä Ä·¥á  è·¥è·¥ú Íú±·¥ú Ä·¥á  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ñ·¥è…¥·¥õ…™…¥·¥ú·¥á ?\n…¥·¥è·¥õ·¥á : ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ú ü·¥Ö  ô·¥á ·¥Ä ·¥Ö·¥áÍú±·¥õ Ä·¥ú·¥Ñ·¥õ…™·¥†·¥á ·¥Ö·¥áÍú±…™·¥Ñ…™·¥è…¥.</b>",

        reply_markup=InlineKeyboardMarkup(btn),

        parse_mode=enums.ParseMode.HTML

    )

@Client.on_message(filters.command("restart") & filters.user(ADMINS))
async def stop_button(bot, message):
    msg = await bot.send_message(text="<b><i> ô·¥è·¥õ …™Íú±  Ä·¥áÍú±·¥õ·¥Ä Ä·¥õ…™…¥…¢</i></b>", chat_id=message.chat.id)       
    await asyncio.sleep(3)
    await msg.edit("<b><i><u> ô·¥è·¥õ …™Íú±  Ä·¥áÍú±·¥õ·¥Ä Ä·¥õ·¥á·¥Ö</u> ‚úÖ</i></b>")
    os.execl(sys.executable, sys.executable, *sys.argv)
